diff --git a/arch/arm/include/asm/arch-apple/m1n1_compat.h b/arch/arm/include/asm/arch-apple/m1n1_compat.h
new file mode 100644
index 0000000000..27ce468f99
--- /dev/null
+++ b/arch/arm/include/asm/arch-apple/m1n1_compat.h
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2021 Thomas Watson <twatson52@icloud.com>
+ */
+
+int apple_m1n1_update_fdt(void *, void*);
diff --git a/arch/arm/mach-apple/Makefile b/arch/arm/mach-apple/Makefile
index 52f30a777b..b4008844a0 100644
--- a/arch/arm/mach-apple/Makefile
+++ b/arch/arm/mach-apple/Makefile
@@ -3,3 +3,4 @@
 obj-y += board.o
 obj-y += lowlevel_init.o
 obj-y += rtkit.o
+obj-y += m1n1_compat.o
\ No newline at end of file
diff --git a/arch/arm/mach-apple/board.c b/arch/arm/mach-apple/board.c
index d61ab1ee1e..334df67da5 100644
--- a/arch/arm/mach-apple/board.c
+++ b/arch/arm/mach-apple/board.c
@@ -11,6 +11,7 @@
 #include <asm/global_data.h>
 #include <asm/io.h>
 #include <asm/system.h>
+#include <asm/arch-apple/m1n1_compat.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -169,6 +170,9 @@ __weak phys_size_t apple_rtkit_size;
 
 int ft_board_setup(void *blob, struct bd_info *bd)
 {
+	if (apple_m1n1_update_fdt(blob, (void *)fw_dtb_pointer))
+		return -1;
+
 	if (apple_rtkit_size > 0) {
 		/* Reserve memory stolen by the mailboxes. */
 		efi_add_memory_map(apple_rtkit_phys_start, apple_rtkit_size,
diff --git a/arch/arm/mach-apple/m1n1_compat.c b/arch/arm/mach-apple/m1n1_compat.c
new file mode 100644
index 0000000000..4688e54d6f
--- /dev/null
+++ b/arch/arm/mach-apple/m1n1_compat.c
@@ -0,0 +1,337 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2021 Thomas Watson <twatson52@icloud.com>
+ */
+
+#include <common.h>
+#include <fdt_support.h>
+
+#define problem(...)			\
+	do {						\
+		printf(__VA_ARGS__);	\
+		return -1;				\
+	} while (0)
+
+static int copy_mem(void *fdt, void *fw_fdt)
+{
+	int fw_node = fdt_path_offset(fw_fdt, "/memory");
+	if (fw_node < 0)
+		problem("memory node missing from firmware\n");
+
+	int node = fdt_path_offset(fdt, "/memory");
+	if (node < 0)
+		problem("memory node missing\n");
+
+	int len;
+	const void *memreg = fdt_getprop(fw_fdt, fw_node, "reg", &len);
+	if (!memreg)
+		problem("could not get reg property of /memory\n");
+
+	if (fdt_setprop(fdt, node, "reg", memreg, len))
+		problem("could not set reg property of /memory\n");
+
+	return 0;
+}
+
+static int copy_mem_rsv(void *fdt, void *fw_fdt)
+{
+	int num_rsvs = fdt_num_mem_rsv(fw_fdt);
+	for (int rsv = 0; rsv < num_rsvs; rsv++)
+	{
+		u64 address, size;
+		if (fdt_get_mem_rsv(fw_fdt, rsv, &address, &size))
+			problem("could not get mem rsv %d\n", rsv);
+
+		if (fdt_add_mem_rsv(fdt, address, size))
+			problem("could not add mem rsv %d\n", rsv);
+	}
+
+	return 0;
+}
+
+static int copy_rng_seed(void *fdt, void *fw_fdt)
+{
+	int fw_node = fdt_path_offset(fw_fdt, "/chosen");
+	if (fw_node < 0)
+		problem("chosen node missing from firmware\n");
+
+	int node = fdt_path_offset(fdt, "/chosen");
+	if (node < 0)
+		problem("chosen node missing\n");
+
+	int len;
+	const void *seed = fdt_getprop(fw_fdt, fw_node, "rng-seed", &len);
+	if (!seed) /* might not be present if m1n1 did not get enough entropy */
+		return 0;
+
+	if (fdt_setprop(fdt, node, "rng-seed", seed, len))
+		problem("could not set rng-seed property of /chosen\n");
+
+	seed = fdt_getprop(fw_fdt, fw_node, "kaslr-seed", &len);
+	if (!seed) /* might not be present if m1n1 did not get enough entropy */
+		return 0;
+
+	if (fdt_setprop(fdt, node, "kaslr-seed", seed, len))
+		problem("could not set kaslr-seed property of /chosen\n");
+
+	return 0;
+}
+
+static int copy_framebuffer(void *fdt, void *fw_fdt)
+{
+	int fw_node = fdt_path_offset(fw_fdt, "/chosen/framebuffer");
+	if (fw_node < 0) /* might not be present if m1n1 did not set it up */
+		return 0;
+
+	int node = fdt_path_offset(fdt, "/chosen/framebuffer");
+	if (node < 0)
+		return 0;
+
+	const char *name = fdt_get_name(fw_fdt, fw_node, NULL);
+	if (!name)
+		problem("could not get framebuffer name\n");
+
+	if (fdt_set_name(fdt, node, name))
+		problem("could not set framebuffer name\n");
+
+	int len;
+	const void *reg = fdt_getprop(fw_fdt, fw_node, "reg", &len);
+	if (!reg)
+		problem("could not get framebuffer reg property\n");
+
+	if (fdt_setprop(fdt, node, "reg", reg, len))
+		problem("could not set framebuffer reg property\n");
+
+	const void *width = fdt_getprop(fw_fdt, fw_node, "width", &len);
+	if (!width)
+		problem("could not get framebuffer width property\n");
+
+	if (fdt_setprop(fdt, node, "width", width, len))
+		problem("could not set framebuffer width property\n");
+
+	const void *height = fdt_getprop(fw_fdt, fw_node, "height", &len);
+	if (!height)
+		problem("could not get framebuffer height property\n");
+
+	if (fdt_setprop(fdt, node, "height", height, len))
+		problem("could not set framebuffer height property\n");
+
+	const void *stride = fdt_getprop(fw_fdt, fw_node, "stride", &len);
+	if (!stride)
+		problem("could not get framebuffer stride property\n");
+
+	if (fdt_setprop(fdt, node, "stride", stride, len))
+		problem("could not set framebuffer stride property\n");
+
+	const void *format = fdt_getprop(fw_fdt, fw_node, "format", &len);
+	if (!format)
+		problem("could not get framebuffer format property\n");
+
+	if (fdt_setprop(fdt, node, "format", format, len))
+		problem("could not set framebuffer format property\n");
+
+	fdt_delprop(fdt, node, "status"); /* un-disable if disabled */
+
+	return 0;
+}
+
+static int copy_mac_addresses(void *fdt, void *fw_fdt)
+{
+	int aliases = fdt_path_offset(fdt, "/aliases");
+	if (aliases < 0)
+		problem("aliases node missing\n");
+
+	int property;
+	fdt_for_each_property_offset(property, fdt, aliases)
+	{
+		const char *if_name = (const char *)fdt_getprop_by_offset(
+			fdt, property, NULL, NULL);
+
+		int node = fdt_path_offset(fdt, if_name);
+		if (!fdt_getprop(fdt, node, "local-mac-address", NULL))
+			continue; /* probably not a network interface */
+
+		int fw_node = fdt_path_offset(fw_fdt, if_name);
+		if (fw_node < 0)
+			problem("corresponding node for %s missing\n", if_name);
+
+		int len;
+		const void *mac = fdt_getprop(fw_fdt, fw_node, "local-mac-address", &len);
+		if (!mac)
+			problem("could not get local-mac-address of %s\n", if_name);
+
+		if (fdt_setprop(fdt, node, "local-mac-address", mac, len))
+			problem("could not set local-mac-address of %s\n", if_name);
+	}
+
+	return 0;
+}
+
+static int copy_disabled_status(void *fdt, void *fw_fdt)
+{
+	const char *soc_path = "/soc/";
+	int fw_soc_node = fdt_path_offset(fw_fdt, soc_path);
+	if (fw_soc_node < 0)
+		problem("soc node missing from firmware\n");
+
+	char dev_path[64];
+	strcpy(dev_path, soc_path);
+	char *dev_name = dev_path + strlen(soc_path);
+
+	/* each time we do fdt_setprop, existing offsets could be invalidated, so
+	we need to start over. this turns this function into O(n^3) probably, but
+	there's only a few devices so it should be okay */
+again: ;
+
+	int soc_node = fdt_path_offset(fdt, soc_path);
+	if (soc_node < 0)
+		problem("soc node missing\n");
+
+	int node;
+	fdt_for_each_subnode(node, fdt, soc_node)
+	{
+		const char *name = fdt_get_name(fdt, node, NULL);
+		if (strncmp(name, "i2c@", 4) && strncmp(name, "usb@", 4))
+			continue;
+
+		const char *status = fdt_getprop(fdt, node, "status", NULL);
+		if (status && !strcmp(status, "disabled"))
+			continue;
+
+		strncpy(dev_name, name, dev_path+64-dev_name);
+		dev_path[63] = '\0';
+		int fw_node = fdt_path_offset(fw_fdt, dev_path);
+		if (fw_node < 0)
+			problem("corresponding node for %s missing\n", dev_path);
+
+		const char *fw_status = fdt_getprop(fw_fdt, fw_node, "status", NULL);
+		if (!fw_status || strcmp(fw_status, "disabled"))
+			continue;
+
+		int iommus_size;
+		const char *iommus = fdt_getprop(fdt, node, "iommus", &iommus_size);
+		if (iommus) {
+			if (iommus_size & 7)
+				problem("invalid iommus size for %s\n", dev_path);
+
+			for (int i = 0; i < iommus_size/8; i++) {
+				u32 phandle = 0;
+				phandle |= (iommus[i*8 + 0] << 24);
+				phandle |= (iommus[i*8 + 1] << 16);
+				phandle |= (iommus[i*8 + 2] << 8);
+				phandle |= iommus[i*8 + 3];
+
+				int io_node;
+				fdt_for_each_subnode(io_node, fdt, soc_node)
+				{
+					if (fdt_get_phandle(fdt, io_node) != phandle)
+						continue;
+
+					const char *status = fdt_getprop(fdt, io_node, "status", NULL);
+					if (status && !strcmp(status, "disabled"))
+						continue;
+
+					if (fdt_setprop_string(fdt, io_node, "status", "disabled") < 0)
+						problem("could not disable iommu %u\n", phandle);
+
+					goto again;
+				}
+			}
+		}
+
+		if (fdt_setprop_string(fdt, node, "status", "disabled") < 0)
+			problem("could not disable device %s\n", dev_path);
+
+		goto again;
+	}
+
+	return 0;
+}
+
+static int copy_cpu(void *fdt, void *fw_fdt)
+{
+	const char *cpus_path = "/cpus/";
+	int fw_cpus_node = fdt_path_offset(fw_fdt, cpus_path);
+	if (fw_cpus_node < 0)
+		problem("cpus node missing from firmware\n");
+
+	char cpu_path[64];
+	strcpy(cpu_path, cpus_path);
+	char *cpu_name = cpu_path + strlen(cpus_path);
+
+	int cpus_node = fdt_path_offset(fdt, cpus_path);
+	if (cpus_node < 0)
+		problem("cpus node missing\n");
+
+	int node;
+	fdt_for_each_subnode(node, fdt, cpus_node)
+	{
+		const char *name = fdt_get_name(fdt, node, NULL);
+		if (strncmp(name, "cpu@", 4))
+			continue;
+
+		strncpy(cpu_name, name, cpu_path+64-cpu_name);
+		cpu_path[63] = '\0';
+		int fw_node = fdt_path_offset(fw_fdt, cpu_path);
+		if (fw_node < 0)
+			problem("corresponding node for %s missing\n", cpu_path);
+
+		int len;
+		const char *release_addr = fdt_getprop(
+			fw_fdt, fw_node, "cpu-release-addr", &len);
+		if (!release_addr)
+			problem("could not get release addr of %s\n", cpu_path);
+
+		if (fdt_setprop(fdt, node, "cpu-release-addr", release_addr, len))
+			problem("could not set release addr of %s\n", cpu_path);
+	}
+
+	return 0;
+}
+
+int apple_m1n1_update_fdt(void *fdt, void *fw_fdt)
+{
+	if (fdt == fw_fdt)
+		return 0;
+
+	fdt_shrink_to_minimum(fdt, 4096);
+
+	int problems = 0;
+	if (copy_mem(fdt, fw_fdt)) {
+		printf("Could not copy memory information!\n");
+		problems = 1;
+	}
+	if (copy_mem_rsv(fdt, fw_fdt)) {
+		printf("Could not copy memory reservation information!\n");
+		problems = 1;
+	}
+	if (copy_rng_seed(fdt, fw_fdt)) {
+		printf("Could not copy RNG seed information!\n");
+		problems = 1;
+	}
+	if (copy_framebuffer(fdt, fw_fdt)) {
+		printf("Could not copy framebuffer information!\n");
+		problems = 1;
+	}
+	if (copy_mac_addresses(fdt, fw_fdt)) {
+		printf("Could not copy MAC address information!\n");
+		problems = 1;
+	}
+	if (copy_disabled_status(fdt, fw_fdt)) {
+		printf("Could not copy device disabled status information!\n");
+		problems = 1;
+	}
+	if (copy_cpu(fdt, fw_fdt)) {
+		printf("Could not copy CPU information!\n");
+		problems = 1;
+	}
+
+	if (problems)
+	{
+		printf("Something went wrong updating the loaded device tree.\n"
+			"This might be cured by updating U-Boot's device tree, "
+			"or m1n1 itself.\n");
+	}
+
+	return 0;
+}
